package com.wufeiqun.zeus.biz.cicd;

import com.wufeiqun.zeus.biz.cicd.entity.CicdBuildContext;
import com.wufeiqun.zeus.biz.cicd.entity.CicdBuildForm;
import com.wufeiqun.zeus.biz.cicd.enums.ArtifactTypeEnum;
import com.wufeiqun.zeus.biz.cicd.enums.ServiceProbeTypeEnum;
import com.wufeiqun.zeus.biz.cmdb.enums.EnvironmentEnum;
import com.wufeiqun.zeus.common.exception.ServiceException;
import com.wufeiqun.zeus.common.utils.PermissionUtil;
import com.wufeiqun.zeus.dao.ApplicationDeployConfig;
import com.wufeiqun.zeus.service.IApplicationDeployConfigService;
import lombok.RequiredArgsConstructor;
import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.stereotype.Service;

import java.text.SimpleDateFormat;
import java.util.*;
import java.util.regex.Pattern;

import static com.wufeiqun.zeus.biz.cicd.enums.ServiceProbeTypeEnum.HTTP;
import static com.wufeiqun.zeus.common.constant.RedisCacheKey.CICD_RATE_LIMIT_BUILD;

/**
 * @author wufeiqun
 * @date 2022-08-16
 * 构建预处理器, 参数校验, 前置任务等
 */
@Service
@RequiredArgsConstructor
public class CicdBuildPreProcessor {
    private final IApplicationDeployConfigService applicationDeployConfigService;
    private final PermissionUtil permissionUtil;
    private final StringRedisTemplate redisTemplate;


    public CicdBuildContext prepareBuildContext(CicdBuildForm.RunBuildForm runBuildForm, String operator) {
        CicdBuildContext buildContext = new CicdBuildContext(runBuildForm, operator);
        generateBuildTagAndSaveToContext(buildContext);
        saveDeployConfigToContext(buildContext);
        saveAutoGeneratedRunExtraArgsToContext(buildContext);
        return buildContext;
    }

    /**
     * 1. 应用配置是否合理, 比如仓库/包路径等配置
     * 2. 用户权限是否合理等
     * @param context 参数
     * @param operator 用户
     */
    public void validate(CicdBuildContext context, String operator) {
        // 通用的校验
        commonValidation(context);
        // 构建限速, 5分钟内最多构建2次
        rateLimit(context, operator);
        // JAVA的检查项
        if (ArtifactTypeEnum.JAR.getType().equals(context.getApplicationDeployConfig().getArtifactType())
        ){
            jarValidation(context);
        }

    }

    private void rateLimit(CicdBuildContext context, String operator){
        // 限制次数(次)
        int times = 10;
        // 时间窗口(秒)
        long periodWindow = 3 * 60L;
        checkRateLimit(times, periodWindow, operator);
        redisTemplate.opsForValue().set(String.format("%s:%s:%s:%s:%s", CICD_RATE_LIMIT_BUILD, operator,
                context.getRunBuildForm().getAppCode(), context.getRunBuildForm().getEnvCode(),
                System.currentTimeMillis() / 1000), "OK", periodWindow, java.util.concurrent.TimeUnit.SECONDS);
    }

    private void checkRateLimit(int times, long periodWindow, String operator){
        Set<String> keys = redisTemplate.keys(String.format("%s:%s:*", CICD_RATE_LIMIT_BUILD, operator));

        if (keys.size() >= times){
            List<Long> existTimeStamp = new ArrayList<>();
            keys.forEach(key -> {
                String[] split = key.split(":");
                existTimeStamp.add(Long.parseLong(split[split.length - 1]));
            });

            existTimeStamp.sort(Comparator.naturalOrder());
            Long earlierValue = Collections.min(existTimeStamp);

            Long nowTimeStamp = System.currentTimeMillis() / 1000;

            long restTime = periodWindow - (nowTimeStamp - earlierValue);

            throw new ServiceException(String.format("构建太频繁, 请%s秒后再试!", restTime));
        }



    }

    private void commonValidation(CicdBuildContext context){
        // git地址必须配置
        if (StringUtils.isBlank(context.getApplicationDeployConfig().getGit())){
            throw new ServiceException("发布配置不完整: git地址必须配置");
        }
        // 制品类型必须配置
        if (ArtifactTypeEnum.JAR.getType().equals(context.getApplicationDeployConfig().getArtifactType())){
            if (StringUtils.isBlank(context.getApplicationDeployConfig().getArtifactType())){
                throw new ServiceException("发布配置不完整: 制品类型必须配置");
            }
        }

        // 探活方式
        if (StringUtils.isBlank(context.getApplicationDeployConfig().getProbeType())){
            throw new ServiceException("发布配置不完整: 探活方式必须配置");
        }
        // 探活方式为HTTP的时候, 必须配置端口和健康检查URL
        if (ServiceProbeTypeEnum.HTTP.getType().equals(context.getApplicationDeployConfig().getProbeType())){
            // 监听端口
            if (Objects.isNull(context.getApplicationDeployConfig().getPort()) ||
                    0 == context.getApplicationDeployConfig().getPort()){
                throw new ServiceException("发布配置不完整: HTTP监听端口必须配置");
            }

            if (StringUtils.isEmpty(context.getApplicationDeployConfig().getHealthCheckUri())){
                throw new ServiceException("发布配置不完整: 健康检查接口未配置");
            }
        }

        if (ServiceProbeTypeEnum.TCP.getType().equals(context.getApplicationDeployConfig().getProbeType())){
            // 监听端口
            if (Objects.isNull(context.getApplicationDeployConfig().getPort()) ||
                    0 == context.getApplicationDeployConfig().getPort()){
                throw new ServiceException("发布配置不完整: RPC监听端口必须配置");
            }
        }
        // 构建分支校验
        if (StringUtils.isBlank(context.getRunBuildForm().getBuildBranch())){
            if (StringUtils.isBlank(context.getApplicationDeployConfig().getBuildBranch())){
                throw new ServiceException("请先配置默认部署分支或者构建的时候选择分支");
            } else {
                context.setBuildBranch(context.getApplicationDeployConfig().getBuildBranch());
            }
        }else {
            context.setBuildBranch(context.getRunBuildForm().getBuildBranch());
        }

    }


    private void permissionValid(CicdBuildContext context, String operator){
        if (EnvironmentEnum.PROD.getCode().equals(context.getRunBuildForm().getEnvCode())){
            if (permissionUtil.noPermission(operator, "cicd:quick:prod:deploy")){
                throw new ServiceException("用户无权限: cicd:quick:prod:deploy");
            }
        }
    }

    private void jarValidation(CicdBuildContext context){
        // 制品名称必须配置
        if (StringUtils.isBlank(context.getApplicationDeployConfig().getArtifactName())){
            throw new ServiceException("发布配置不完整: 制品名称必须配置");
        }
        // 制品路径必须配置
        if (StringUtils.isBlank(context.getApplicationDeployConfig().getArtifactPath())){
            throw new ServiceException("发布配置不完整: 制品路径必须配置");
        }
    }

    private void generateBuildTagAndSaveToContext(CicdBuildContext context) {
        SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMddHHmmss");
        context.setBuildTag(String.format("%s-%s-%s-%s", context.getRunBuildForm().getAppCode(),
                context.getRunBuildForm().getEnvCode(), context.getOperator(), sdf.format(new Date())));
    }

    private void saveDeployConfigToContext(CicdBuildContext context) {
        ApplicationDeployConfig config = applicationDeployConfigService.getByAppcodeAndEnvCode(
                context.getRunBuildForm().getAppCode(),
                context.getRunBuildForm().getEnvCode()
                );
        context.setApplicationDeployConfig(config);
    }

    /**
     * 保存自定义运行命令参数, 对于常规的Springboot项目来说, Python异步任务那边定义了java RUN_EXTRA_ARGS app.jar
     * 用户在应用发布配置处定义RUN_EXTRA_ARGS, 其实很多通用配置比如监听端口, 内存配置等运维平台可以自动配置, 不需要用户来配置
     * 所以有了下面的代码, 主要生成的是 -Xms3072m -Xmx3072m  -Dspring.profiles.active=prod -Dserver.port=13009
     * 并且用户自定义的会覆盖这一部分, 用户填写不填写都行的
     */
    private void saveAutoGeneratedRunExtraArgsToContext(CicdBuildContext context) {
        ApplicationDeployConfig config = applicationDeployConfigService.getByAppcodeAndEnvCode(
                context.getRunBuildForm().getAppCode(),
                context.getRunBuildForm().getEnvCode()
        );
        // 针对常规的SpringBoot项目
        if (ArtifactTypeEnum.JAR.getType().equals(context.getApplicationDeployConfig().getArtifactType())){
            // 堆内存大小的设置为容器Limit的90%
            String autoGeneratedRunExtraArgs = String.format("-Xms%sm -Xmx%sm -Dspring.profiles.active=%s -Dserver.port=%s -XX:+UseG1GC -Dfile.encoding=UTF8 -Dmail.mime.charset=UTF-8",
                    (int)(config.getKubernetesLimitMemory() * 0.7), (int)(config.getKubernetesLimitMemory() * 0.7),
                    context.getApplicationDeployConfig().getProfile(), config.getPort());
            context.setAutoGeneratedRunExtraArgs(autoGeneratedRunExtraArgs);
        }

    }
}
